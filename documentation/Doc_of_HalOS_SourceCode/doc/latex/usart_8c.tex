\hypertarget{usart_8c}{
\section{E:/Ausbildung/Semester3/Kopie von AVR32\_\-Work1/Halos\_\-Development/src/hal/ports/avr32/ap7x/ap7000/usart.c File Reference}
\label{usart_8c}\index{E:/Ausbildung/Semester3/Kopie von AVR32\_\-Work1/Halos\_\-Development/src/hal/ports/avr32/ap7x/ap7000/usart.c@{E:/Ausbildung/Semester3/Kopie von AVR32\_\-Work1/Halos\_\-Development/src/hal/ports/avr32/ap7x/ap7000/usart.c}}
}
USART driver library.  


{\tt \#include \char`\"{}usart.h\char`\"{}}\par
{\tt \#include \char`\"{}error.h\char`\"{}}\par
{\tt \#include \char`\"{}nlao\_\-io.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
void \hyperlink{usart_8c_e994c1e7797dda76388176f208a2e6f2}{usart\_\-reset} (volatile struct avr32\_\-usart\_\-t $\ast$usart)
\item 
int \hyperlink{usart_8c_48c8d76fc9fdde84b94a6e09184a6446}{usart\_\-init\_\-rs232} (volatile struct avr32\_\-usart\_\-t $\ast$usart, struct \hyperlink{structusart__options__t}{usart\_\-options\_\-t} $\ast$opt, long cpu\_\-hz)
\item 
void \hyperlink{usart_8c_5f5ba5edef2948c6e5e8c37ba07e5989}{usart\_\-reset\_\-status} (volatile struct avr32\_\-usart\_\-t $\ast$usart)
\begin{CompactList}\small\item\em Reset error status. \item\end{CompactList}\item 
void \hyperlink{usart_8c_0cd4c3b95035f5943696ffd9b56ee494}{usart\_\-bw\_\-write\_\-char} (volatile struct avr32\_\-usart\_\-t $\ast$usart, int c)
\item 
int \hyperlink{usart_8c_26a849327e3bccdef17734f30667d9bd}{usart\_\-write\_\-char} (volatile struct avr32\_\-usart\_\-t $\ast$usart, int c)
\item 
int \hyperlink{usart_8c_ad19b20067ca5ccf90d584e3b09ab02a}{usart\_\-getchar} (volatile struct avr32\_\-usart\_\-t $\ast$usart)
\item 
int \hyperlink{usart_8c_908695fc913f77a6c1ab2a89e201a1fd}{usart\_\-putchar} (volatile struct avr32\_\-usart\_\-t $\ast$usart, int c)
\end{CompactItemize}


\subsection{Detailed Description}
USART driver library. 

This file contains basic drivers for the AVR32 USART, with support for all all modes, settings and clock speeds.

\begin{itemize}
\item Compiler: IAR EWAAVR32 and GNU GCC for AVR32\item Supported actDevices: All AVR32 actDevices with a USART module can be used.\item AppNote: AVR32100 - Communication with the AVR32 USART\end{itemize}


\begin{Desc}
\item[Author:]Atmel Corporation: \href{http://www.atmel.com}{\tt http://www.atmel.com} \par
 Support email: \href{mailto:avr32@atmel.com}{\tt avr32@atmel.com}\end{Desc}
\begin{Desc}
\item[Name]\end{Desc}
\begin{Desc}
\item[Revision]1.7 \end{Desc}
\begin{Desc}
\item[RCSfile]\hyperlink{usart_8c}{usart.c},v \end{Desc}
\begin{Desc}
\item[Date]2006/05/10 13:00:07 \end{Desc}


\subsection{Function Documentation}
\hypertarget{usart_8c_0cd4c3b95035f5943696ffd9b56ee494}{
\index{usart.c@{usart.c}!usart\_\-bw\_\-write\_\-char@{usart\_\-bw\_\-write\_\-char}}
\index{usart\_\-bw\_\-write\_\-char@{usart\_\-bw\_\-write\_\-char}!usart.c@{usart.c}}
\subsubsection[{usart\_\-bw\_\-write\_\-char}]{\setlength{\rightskip}{0pt plus 5cm}void usart\_\-bw\_\-write\_\-char (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart}, \/  int {\em c})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{usart_8c_0cd4c3b95035f5943696ffd9b56ee494}


A busy wait for writing a character to the usart. Use with $\ast$caution$\ast$ \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \item[{\em c}]The character (up to 9 bits) to transmit \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]None \end{Desc}
\hypertarget{usart_8c_ad19b20067ca5ccf90d584e3b09ab02a}{
\index{usart.c@{usart.c}!usart\_\-getchar@{usart\_\-getchar}}
\index{usart\_\-getchar@{usart\_\-getchar}!usart.c@{usart.c}}
\subsubsection[{usart\_\-getchar}]{\setlength{\rightskip}{0pt plus 5cm}int usart\_\-getchar (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart})}}
\label{usart_8c_ad19b20067ca5ccf90d584e3b09ab02a}


Wait until a character is recevied, and return this. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The received character, or -1 upon error \end{Desc}
\hypertarget{usart_8c_48c8d76fc9fdde84b94a6e09184a6446}{
\index{usart.c@{usart.c}!usart\_\-init\_\-rs232@{usart\_\-init\_\-rs232}}
\index{usart\_\-init\_\-rs232@{usart\_\-init\_\-rs232}!usart.c@{usart.c}}
\subsubsection[{usart\_\-init\_\-rs232}]{\setlength{\rightskip}{0pt plus 5cm}int usart\_\-init\_\-rs232 (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart}, \/  struct {\bf usart\_\-options\_\-t} $\ast$ {\em opt}, \/  long {\em cpu\_\-hz})}}
\label{usart_8c_48c8d76fc9fdde84b94a6e09184a6446}


Setup the usart to use the standard RS232 protocol \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \item[{\em $\ast$opt}]Options needed to set up RS232 communcation (see \hyperlink{structusart__options__t}{usart\_\-options\_\-t}) \item[{\em cpu\_\-hz}]The usart clk frequency \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]USART\_\-SUCCESS or USART\_\-INVALID\_\-INPUT \end{Desc}
\hypertarget{usart_8c_908695fc913f77a6c1ab2a89e201a1fd}{
\index{usart.c@{usart.c}!usart\_\-putchar@{usart\_\-putchar}}
\index{usart\_\-putchar@{usart\_\-putchar}!usart.c@{usart.c}}
\subsubsection[{usart\_\-putchar}]{\setlength{\rightskip}{0pt plus 5cm}int usart\_\-putchar (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart}, \/  int {\em c})}}
\label{usart_8c_908695fc913f77a6c1ab2a89e201a1fd}


Send a character with the usart \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \item[{\em c}]Character to write \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]0 if char was written, -1 if the function timed out before the usart transmitter became ready to send \end{Desc}
\hypertarget{usart_8c_e994c1e7797dda76388176f208a2e6f2}{
\index{usart.c@{usart.c}!usart\_\-reset@{usart\_\-reset}}
\index{usart\_\-reset@{usart\_\-reset}!usart.c@{usart.c}}
\subsubsection[{usart\_\-reset}]{\setlength{\rightskip}{0pt plus 5cm}void usart\_\-reset (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart})}}
\label{usart_8c_e994c1e7797dda76388176f208a2e6f2}


This function will reset the USART, and disable TX and RX \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]nothing \end{Desc}
\hypertarget{usart_8c_5f5ba5edef2948c6e5e8c37ba07e5989}{
\index{usart.c@{usart.c}!usart\_\-reset\_\-status@{usart\_\-reset\_\-status}}
\index{usart\_\-reset\_\-status@{usart\_\-reset\_\-status}!usart.c@{usart.c}}
\subsubsection[{usart\_\-reset\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}void usart\_\-reset\_\-status (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart})}}
\label{usart_8c_5f5ba5edef2948c6e5e8c37ba07e5989}


Reset error status. 

This function resets the status bits indicating that a parity error, framing error or overrun has occured. The rxbreak bit, indicating a start/end of break condition on the rx-line, is also reset. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]nothing \end{Desc}
\hypertarget{usart_8c_26a849327e3bccdef17734f30667d9bd}{
\index{usart.c@{usart.c}!usart\_\-write\_\-char@{usart\_\-write\_\-char}}
\index{usart\_\-write\_\-char@{usart\_\-write\_\-char}!usart.c@{usart.c}}
\subsubsection[{usart\_\-write\_\-char}]{\setlength{\rightskip}{0pt plus 5cm}int usart\_\-write\_\-char (volatile struct avr32\_\-usart\_\-t $\ast$ {\em usart}, \/  int {\em c})}}
\label{usart_8c_26a849327e3bccdef17734f30667d9bd}


If the transmitter is ready; write the given character to the TX buffer \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$usart}]Base address of the usart \item[{\em c}]The character (up to 9 bits) to transmit \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]USART\_\-SUCCESS when the transmitter is ready USART\_\-TX\_\-BUSY when the transmitter is busy \end{Desc}
