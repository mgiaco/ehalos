<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Halos: Inverted Page Table</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Inverted Page Table<br>
<small>
[<a class="el" href="group___v_m_m.html">Virtual Memory Management</a>]</small>
</h1>Inverted Page Table. The basic idea of an inverted page table is to have only one page table for the complete memory and all loaded processes. The entries identify the physical frames rather than the virtual pages. The main advantage is that no TLB flush is necessary between process switches. Another advantage is that the memory usage of the page table is moderate. The search speed of a given Page Table Entry depends heavily on the hash-algorithm that uses ASID and VPN. With a goog hash-algorithm two to three lookups are necessary. A disadvantage is that no memory sharing is possible with the standard variant.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g633bd0e0b24708177aebf72079714748">initInvertedPageTable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g4495d1e87487776b13d7c0f8c8c75ec9">searchPageTableEntryAndHashAnchorAndPreviousInIPT</a> (<a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh, <a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a> hHashAnchorPTEntry, <a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a> hPrevPTEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g1ce348812f454f6c840bbbbcbad37add">searchPageTableEntryAndHashAnchorInIPT</a> (<a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh, <a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a> hHashAnchorPTEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g6a86fa230ac72f34daf47257381eb181">searchPageTableEntryAndPreviousInIPT</a> (<a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh, <a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a> hatEntry, <a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a> hPrevPTEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g150394a17b25cd9912983172c7b3803a">searchPageTableEntryInIPT</a> (<a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh, <a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a> hatEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#gceafcd302dd2b1aca0074e443f53d093">searchPageTableEntryAndPreviousInPTE</a> (<a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> pPTEntry, <a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh, <a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a> hPrevPTEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g87ad4a7444ff78fa4502299524d8a5b9">searchPageTableEntryInPTE</a> (<a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> pPTEntry, <a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_t_l_b_e_l_o.html">TLBELOPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#ga1a233ecd4f829d64f29c55c5c2b369b">searchPageTableEntryLowInIPT</a> (<a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh, <a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a> hatEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_t_l_b_e_l_o.html">TLBELOPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g4d5cd060a657ba3d732c739461a583a9">searchPageTableEntryLowInPTE</a> (<a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> pPTEntry, <a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a> pTLBEntryHigh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g84c6b60a0c0d560611edc86fd07a072f">getIPTIndex</a> (<a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a> hatEntry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_m_m___i_p_t.html#g5bf5d5affcca902498ae333f71928885">lastPageTableEntryOfPTEChain</a> (<a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> pPTEntry)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Inverted Page Table. The basic idea of an inverted page table is to have only one page table for the complete memory and all loaded processes. The entries identify the physical frames rather than the virtual pages. The main advantage is that no TLB flush is necessary between process switches. Another advantage is that the memory usage of the page table is moderate. The search speed of a given Page Table Entry depends heavily on the hash-algorithm that uses ASID and VPN. With a goog hash-algorithm two to three lookups are necessary. A disadvantage is that no memory sharing is possible with the standard variant. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>... </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>drb8w </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.0.1 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g84c6b60a0c0d560611edc86fd07a072f"></a><!-- doxytag: member="InvertedPageTable.h::getIPTIndex" ref="g84c6b60a0c0d560611edc86fd07a072f" args="(HashAnchorTableEntry hatEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t getIPTIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a>&nbsp;</td>
          <td class="paramname"> <em>hatEntry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transforms an Hash Anchor Table Entry to an appropriate Inverted Page Table index. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hatEntry</em>&nbsp;</td><td>the HAT Entry to transform </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g633bd0e0b24708177aebf72079714748"></a><!-- doxytag: member="InvertedPageTable.h::initInvertedPageTable" ref="g633bd0e0b24708177aebf72079714748" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initInvertedPageTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the inverted page table with IllegalTLBEntryHigh for the tlbEntryHigh-Parts to indicate possible usage and appropriate page frame numbers for the tlbEntryLow-Parts to indicate the physical frame. The page frame numbers start from PFNOFFSET to upper end. 
</div>
</div><p>
<a class="anchor" name="g5bf5d5affcca902498ae333f71928885"></a><!-- doxytag: member="InvertedPageTable.h::lastPageTableEntryOfPTEChain" ref="g5bf5d5affcca902498ae333f71928885" args="(PageTableEntryPtr pPTEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> lastPageTableEntryOfPTEChain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pPTEntry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last Page Table Entry of the chain where given Page Table Entry is in. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPTEntry</em>&nbsp;</td><td>a Page Table Entry in the chain </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4495d1e87487776b13d7c0f8c8c75ec9"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryAndHashAnchorAndPreviousInIPT" ref="g4495d1e87487776b13d7c0f8c8c75ec9" args="(TLBEHIPtr pTLBEntryHigh, PageTableEntryHdl hHashAnchorPTEntry, PageTableEntryHdl hPrevPTEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> searchPageTableEntryAndHashAnchorAndPreviousInIPT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a>&nbsp;</td>
          <td class="paramname"> <em>hHashAnchorPTEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a>&nbsp;</td>
          <td class="paramname"> <em>hPrevPTEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the corresponding page table entry depending on ASID and VPN of given page table high part in the Inverted Page Table. Also returns the corresponding Hash Anchor - Page Table Entry and the Page Table Entry before the searched Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the Page Table Entry high part that delivers the ASID and VPN for the search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hHashAnchorPTEntry</em>&nbsp;</td><td>the Page Table Entry that is identified by the Hash Anchor Table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hPrevPTEntry</em>&nbsp;</td><td>the Page Table Entry in the hash chain before the searched Page Table Entry </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the found Page Table Entry pointer or NULL if not found </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1ce348812f454f6c840bbbbcbad37add"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryAndHashAnchorInIPT" ref="g1ce348812f454f6c840bbbbcbad37add" args="(TLBEHIPtr pTLBEntryHigh, PageTableEntryHdl hHashAnchorPTEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> searchPageTableEntryAndHashAnchorInIPT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a>&nbsp;</td>
          <td class="paramname"> <em>hHashAnchorPTEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the corresponding page table entry depending on ASID and VPN of given page table high part in the Inverted Page Table. Also returns the corresponding Hash Anchor - Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the Page Table Entry high part that delivers the ASID and VPN for the search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hHashAnchorPTEntry</em>&nbsp;</td><td>the Page Table Entry that is identified by the Hash Anchor Table </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the found Page Table Entry pointer or NULL if not found </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6a86fa230ac72f34daf47257381eb181"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryAndPreviousInIPT" ref="g6a86fa230ac72f34daf47257381eb181" args="(TLBEHIPtr pTLBEntryHigh, HashAnchorTableEntry hatEntry, PageTableEntryHdl hPrevPTEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> searchPageTableEntryAndPreviousInIPT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a>&nbsp;</td>
          <td class="paramname"> <em>hatEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a>&nbsp;</td>
          <td class="paramname"> <em>hPrevPTEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the corresponding page table entry depending on ASID and VPN of given page table high part in the Inverted Page Table. Additional the Hash Anchor Table Entry of the actual hash chain must be delivered to improve search space. Also returns the Page Table Entry before the searched Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the Page Table Entry high part that delivers the ASID and VPN for the search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hatEntry</em>&nbsp;</td><td>the Hash Anchor Table Entry that identified the hash chain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hPrevPTEntry</em>&nbsp;</td><td>the Page Table Entry in the hash chain before the searched Page Table Entry </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the found Page Table Entry pointer or NULL if not found </dd></dl>

</div>
</div><p>
<a class="anchor" name="gceafcd302dd2b1aca0074e443f53d093"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryAndPreviousInPTE" ref="gceafcd302dd2b1aca0074e443f53d093" args="(PageTableEntryPtr pPTEntry, TLBEHIPtr pTLBEntryHigh, PageTableEntryHdl hPrevPTEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> searchPageTableEntryAndPreviousInPTE           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pPTEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryHdl</a>&nbsp;</td>
          <td class="paramname"> <em>hPrevPTEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the corresponding page table entry depending on ASID and VPN of given page table high part in the hash chain of given Page Table Entry. Additionally the Page Table Entry before the searched Page Table Entry is delivered. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPTEntry</em>&nbsp;</td><td>the Page Table Entry that is the start entry of the hash chain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the Page Table Entry high part that delivers the ASID and VPN for the search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hPrevPTEntry</em>&nbsp;</td><td>the Page Table Entry in the hash chain before the searched Page Table Entry </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the found Page Table Entry pointer or NULL if not found </dd></dl>

</div>
</div><p>
<a class="anchor" name="g150394a17b25cd9912983172c7b3803a"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryInIPT" ref="g150394a17b25cd9912983172c7b3803a" args="(TLBEHIPtr pTLBEntryHigh, HashAnchorTableEntry hatEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> searchPageTableEntryInIPT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a>&nbsp;</td>
          <td class="paramname"> <em>hatEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the corresponding page table entry depending on ASID and VPN of given page table high part in the Inverted Page Table. Additional the Hash Anchor Table Entry of the actual hash chain must be delivered to improve search space. Also returns the Page Table Entry before the searched Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the Page Table Entry high part that delivers the ASID and VPN for the search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hatEntry</em>&nbsp;</td><td>the Hash Anchor Table Entry that identified the hash chain </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the found Page Table Entry pointer or NULL if not found </dd></dl>

</div>
</div><p>
<a class="anchor" name="g87ad4a7444ff78fa4502299524d8a5b9"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryInPTE" ref="g87ad4a7444ff78fa4502299524d8a5b9" args="(PageTableEntryPtr pPTEntry, TLBEHIPtr pTLBEntryHigh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a> searchPageTableEntryInPTE           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pPTEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the corresponding page table entry depending on ASID and VPN of given page table high part in the hash chain of given Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPTEntry</em>&nbsp;</td><td>the Page Table Entry that is the start entry of the hash chain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the Page Table Entry high part that delivers the ASID and VPN for the search </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the found Page Table Entry pointer or NULL if not found </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga1a233ecd4f829d64f29c55c5c2b369b"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryLowInIPT" ref="ga1a233ecd4f829d64f29c55c5c2b369b" args="(TLBEHIPtr pTLBEntryHigh, HashAnchorTableEntry hatEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_l_b_e_l_o.html">TLBELOPtr</a> searchPageTableEntryLowInIPT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_m_m___h_a_t.html#g06b98a0b294446afee1b27a04682d7c2">HashAnchorTableEntry</a>&nbsp;</td>
          <td class="paramname"> <em>hatEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the low part of the Page Table Entry in the given hash chain identified by given Hash Anchor Table Entry. The searched Page Table Entry is identified by the ASID and VPN of given high part of the searched Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the high part of the searched Page Table Entry i.e. its low part </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hatEntry</em>&nbsp;</td><td>the Hash Anchor Table Entry that identifies the hash chain of Page Table Entries </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>low part of found Page Table Entry or NULL otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4d5cd060a657ba3d732c739461a583a9"></a><!-- doxytag: member="InvertedPageTable.h::searchPageTableEntryLowInPTE" ref="g4d5cd060a657ba3d732c739461a583a9" args="(PageTableEntryPtr pPTEntry, TLBEHIPtr pTLBEntryHigh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_l_b_e_l_o.html">TLBELOPtr</a> searchPageTableEntryLowInPTE           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_page_table_entry.html">PageTableEntryPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pPTEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_l_b_e_h_i.html">TLBEHIPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pTLBEntryHigh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search the low part of the Page Table Entry in the given hash chain via the given Page Table Entry. The searched Page Table Entry is identified by the ASID and VPN of given high part of the searched Page Table Entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPTEntry</em>&nbsp;</td><td>the Page Table Entry that delivers the hash chain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTLBEntryHigh</em>&nbsp;</td><td>the high part of the searched Page Table Entry i.e. its low part </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>low part of found Page Table Entry or NULL otherwise </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Feb 8 18:43:25 2009 for Halos by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
