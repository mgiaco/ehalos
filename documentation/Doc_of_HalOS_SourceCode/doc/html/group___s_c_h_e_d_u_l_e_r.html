<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Halos: Scheduler</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Scheduler<br>
<small>
[<a class="el" href="group___p_r_o_c_e_s_s___m_a_n_a_g_e_r.html">Process Manager</a>]</small>
</h1>Task/process scheduler for Halos, implemented scheduling algorithm: simple Round Robin (not priority based).  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga40645236fdec3db71ba1c464fc61012"></a><!-- doxytag: member="SCHEDULER::TASK_INITIALIZED" ref="ga40645236fdec3db71ba1c464fc61012" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#ga40645236fdec3db71ba1c464fc61012">TASK_INITIALIZED</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constants for the different task states. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g6f966a27cb81e25cbbeb00209e4f425a">init_scheduler</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *<a class="el" href="group___s_c_h_e_d_u_l_e_r.html#gc4ccbf885c8f3faf19274dced0c7216a">ptrIdleTask</a>, <a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrNewTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g8cf010ead07e0d3c9f2fec540ca41222">initIdleTask</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrIdleT)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g0a823bd7dfbe610f6fb79f213bad887a">putTask_to_RUNABLQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrNewTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g915e6a1a7af8610eb748b2a71aed8e25">putTask_to_SUSPENDEDQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrNewTask, uint32_t suspendTime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#gb30df8d2157564bf9b3ab2fb0fc4e416">removeTask_from_RUNABLQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrRemTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g37148b0b5230fbd6a7e27996d7c7559b">schedule</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g7f3d982256a144718b4d566764ab3380">getRunningTask</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g30026f24b7df3171d12eac61e94c654e">changeTaskStateAndReorg</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrCurTask, uint8_t newState)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g98be6cb7c674631c08f257f0f361bdba">top</a> (<a class="el" href="group___h_s_y_s_t_e_m___a_p_i.html#g3be61222bdb3a1adfbf7720dec596851">process_info_block_t</a> *allocatedListOfInfBlks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g464f3d8698435a2cce5660213ad5e2a1">get_nr_of_processes</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g2c41093c81844ed2a2b8336ea7e65c22">count_queue</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrTaskList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g65919f434a296ebe721e10c695c76fd7">cleanupScheduler</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#ge4efef9d981ec735fdb928fa859e90c8">updateAllSupendedTasks</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g4f5f47b0e6e09f0d8f20b174a451d3f9">putTask_to_BLOCKEDQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrNewTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g5b3f8e0a1ef0153e3701fd5c353ffb30">putTask_to_STOPPEDQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrNewTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g36b5565a1de28332f76c8201e3978710">removeTask_from_BLOCKEDQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrRemTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#gdd6fd538df662b324399533cd7ee6983">removeTask_from_STOPPEDQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrRemTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g6269ef2491853b54f6857e84a495e0a3">removeTask_from_SUSPENDEDQ</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrRemTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g2b9b2d937366c49222722abf3d3ca448">deleteTask</a> (<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *ptrCurTask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#gbc336985438a0d2ef4e4386aca2fec83">updateCpuTimes</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g037e710f906b1ff253e859e70add039b">reorganizeSuspendedTasks</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4e6e6409119b57e144bf39f102d3aa4c"></a><!-- doxytag: member="SCHEDULER::ptrRunningTask" ref="g4e6e6409119b57e144bf39f102d3aa4c" args="" -->
volatile <a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g4e6e6409119b57e144bf39f102d3aa4c">ptrRunningTask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current Running Task - pointer to current running task (holds only one task!). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc4ccbf885c8f3faf19274dced0c7216a"></a><!-- doxytag: member="SCHEDULER::ptrIdleTask" ref="gc4ccbf885c8f3faf19274dced0c7216a" args="" -->
<a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#gc4ccbf885c8f3faf19274dced0c7216a">ptrIdleTask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Idle Task for Scheduler - pointer to idle task, is used if system has no other task to run and for performance metrics. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Task/process scheduler for Halos, implemented scheduling algorithm: simple Round Robin (not priority based). 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>... </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>maex.sp Markus Speckle </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.0.1 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g30026f24b7df3171d12eac61e94c654e"></a><!-- doxytag: member="sched.h::changeTaskStateAndReorg" ref="g30026f24b7df3171d12eac61e94c654e" args="(PCtrlBlock_t *ptrCurTask, uint8_t newState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void changeTaskStateAndReorg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrCurTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>newState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes the state of the task and reorganizes the task queues, e.g. remove from BLOCKEDQ, change state of task an put to RUNNABLEQ <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrCurTask</em>&nbsp;</td><td>the task which should be changed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newState</em>&nbsp;</td><td>new state for this task </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g65919f434a296ebe721e10c695c76fd7"></a><!-- doxytag: member="sched.h::cleanupScheduler" ref="g65919f434a296ebe721e10c695c76fd7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cleanupScheduler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cleans the scheduler pointer, free´s alls queues and set pointer to NULL (mainly used for testing issues) 
</div>
</div><p>
<a class="anchor" name="g2c41093c81844ed2a2b8336ea7e65c22"></a><!-- doxytag: member="sched.h::count_queue" ref="g2c41093c81844ed2a2b8336ea7e65c22" args="(PCtrlBlock_t *ptrTaskList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t count_queue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrTaskList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of tasks (length) in a task-queue <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrTaskList</em>&nbsp;</td><td>queue list for counting </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>length of task queue </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2b9b2d937366c49222722abf3d3ca448"></a><!-- doxytag: member="sched.h::deleteTask" ref="g2b9b2d937366c49222722abf3d3ca448" args="(PCtrlBlock_t *ptrCurTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deleteTask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrCurTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free´s the memory and the task itselfe from the HALOS system, after this function call the task is completly deleted from the system and scheduler <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrCurTask</em>&nbsp;</td><td>the task to be deleted from HALOS </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g464f3d8698435a2cce5660213ad5e2a1"></a><!-- doxytag: member="sched.h::get_nr_of_processes" ref="g464f3d8698435a2cce5660213ad5e2a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t get_nr_of_processes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of current tasks/processes in the scheduler <dl class="return" compact><dt><b>Returns:</b></dt><dd>number of tasks </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7f3d982256a144718b4d566764ab3380"></a><!-- doxytag: member="sched.h::getRunningTask" ref="g7f3d982256a144718b4d566764ab3380" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a>* getRunningTask           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current running task, after the <a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g37148b0b5230fbd6a7e27996d7c7559b">schedule()</a> operation this pointer holds the new current task, this can also be the idle task if there was no other runnable task available 
</div>
</div><p>
<a class="anchor" name="g6f966a27cb81e25cbbeb00209e4f425a"></a><!-- doxytag: member="sched.h::init_scheduler" ref="g6f966a27cb81e25cbbeb00209e4f425a" args="(PCtrlBlock_t *ptrIdleTask, PCtrlBlock_t *ptrNewTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a>* init_scheduler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrIdleTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrNewTask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializing the scheduler at startup, needs idle task and task to run 1.) inits idle task 2.) puts first Task into runnable queue 3.) schedules the tasks... should so far the ptrNewTask because its the first task to run <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrIdleTask</em>&nbsp;</td><td>the idle task for the scheduler (empty task which is doing nothing, only performance counting) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptrNewTask</em>&nbsp;</td><td>starting task ((this is normally the shell task but can also be NULL) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>next task to be run (new current running task) </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8cf010ead07e0d3c9f2fec540ca41222"></a><!-- doxytag: member="sched.h::initIdleTask" ref="g8cf010ead07e0d3c9f2fec540ca41222" args="(PCtrlBlock_t *ptrIdleT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initIdleTask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrIdleT</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts idle task to the scheduler evironment, this task is only "executed" if there is no other task in the runnable queue, idleTask should therefore also be used for performance metrics analyses <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrIdleT</em>&nbsp;</td><td>the idle Task </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4f5f47b0e6e09f0d8f20b174a451d3f9"></a><!-- doxytag: member="sched.h::putTask_to_BLOCKEDQ" ref="g4f5f47b0e6e09f0d8f20b174a451d3f9" args="(PCtrlBlock_t *ptrNewTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void putTask_to_BLOCKEDQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrNewTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put tasks to the blocked queue, here are all tasks hold which are waiting for any IO operations <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrNewTask</em>&nbsp;</td><td>the task for the blocked-queue </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0a823bd7dfbe610f6fb79f213bad887a"></a><!-- doxytag: member="sched.h::putTask_to_RUNABLQ" ref="g0a823bd7dfbe610f6fb79f213bad887a" args="(PCtrlBlock_t *ptrNewTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void putTask_to_RUNABLQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrNewTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts task to the runnable queue, if we call <a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g37148b0b5230fbd6a7e27996d7c7559b">schedule()</a> -&gt; one of the next task from this runnalbe queue will be returned as the next running task <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrNewTask</em>&nbsp;</td><td>the new task </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g5b3f8e0a1ef0153e3701fd5c353ffb30"></a><!-- doxytag: member="sched.h::putTask_to_STOPPEDQ" ref="g5b3f8e0a1ef0153e3701fd5c353ffb30" args="(PCtrlBlock_t *ptrNewTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void putTask_to_STOPPEDQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrNewTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put tasks to the stopped queue, here are all tasks which ended and can be deleted afterwards <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrNewTask</em>&nbsp;</td><td>the task for the stopped-queue </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g915e6a1a7af8610eb748b2a71aed8e25"></a><!-- doxytag: member="sched.h::putTask_to_SUSPENDEDQ" ref="g915e6a1a7af8610eb748b2a71aed8e25" args="(PCtrlBlock_t *ptrNewTask, uint32_t suspendTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void putTask_to_SUSPENDEDQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrNewTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>suspendTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts task to the suspended-queue with a speciefied suspend-time, task will be hold in the queue as long as the suspend time is not reached <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#ge4efef9d981ec735fdb928fa859e90c8">updateAllSupendedTasks()</a> for putting back tasks from suspended queue to runnable queue </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrNewTask</em>&nbsp;</td><td>task to be suspended </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suspendTime</em>&nbsp;</td><td>suspend time (the amount of systicks to wait in the suspend queue) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g36b5565a1de28332f76c8201e3978710"></a><!-- doxytag: member="sched.h::removeTask_from_BLOCKEDQ" ref="g36b5565a1de28332f76c8201e3978710" args="(PCtrlBlock_t *ptrRemTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeTask_from_BLOCKEDQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrRemTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes task from blocked-IO-queue, state will not be changed <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrRemTask</em>&nbsp;</td><td>task to be removed from queue </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb30df8d2157564bf9b3ab2fb0fc4e416"></a><!-- doxytag: member="sched.h::removeTask_from_RUNABLQ" ref="gb30df8d2157564bf9b3ab2fb0fc4e416" args="(PCtrlBlock_t *ptrRemTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeTask_from_RUNABLQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrRemTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes task from runnable queue, state will not be changed <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrRemTask</em>&nbsp;</td><td>the task which should be removed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdd6fd538df662b324399533cd7ee6983"></a><!-- doxytag: member="sched.h::removeTask_from_STOPPEDQ" ref="gdd6fd538df662b324399533cd7ee6983" args="(PCtrlBlock_t *ptrRemTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeTask_from_STOPPEDQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrRemTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes task from stopped queue, state will not be changed <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrRemTask</em>&nbsp;</td><td>task to be removed from queue </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6269ef2491853b54f6857e84a495e0a3"></a><!-- doxytag: member="sched.h::removeTask_from_SUSPENDEDQ" ref="g6269ef2491853b54f6857e84a495e0a3" args="(PCtrlBlock_t *ptrRemTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeTask_from_SUSPENDEDQ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ptrRemTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes task from suspended-queue, state will not be changed <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptrRemTask</em>&nbsp;</td><td>task to be removed from queue </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g037e710f906b1ff253e859e70add039b"></a><!-- doxytag: member="sched.h::reorganizeSuspendedTasks" ref="g037e710f906b1ff253e859e70add039b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t reorganizeSuspendedTasks           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reorganizes the SUSPENDED tasks queue, checks if there are tasks available which can be put to the runnable queue, call this function until return 1 is received, this is needed if there are more than 1 task have to be moved to runnable queue <dl class="return" compact><dt><b>Returns:</b></dt><dd>: 0 = one task has been found and reorganized, maybe one or more other tasks left to reorganize, return: 1 = all tasks have been checked (and if necessary also moved to runnable queue) </dd></dl>

</div>
</div><p>
<a class="anchor" name="g37148b0b5230fbd6a7e27996d7c7559b"></a><!-- doxytag: member="sched.h::schedule" ref="g37148b0b5230fbd6a7e27996d7c7559b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess_control_block.html">PCtrlBlock_t</a>* schedule           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Schedules with round robin algorithmus through the runnable queue and returns the next task which should be started for the next time quantum (time slice), returns next task which schould be executed (depends if new runnable tasks available and on priority of tasks (round robin), if no runnable task available the idle task will become the next running task <dl class="return" compact><dt><b>Returns:</b></dt><dd>the next task to be run (current runningtask) </dd></dl>

</div>
</div><p>
<a class="anchor" name="g98be6cb7c674631c08f257f0f361bdba"></a><!-- doxytag: member="sched.h::top" ref="g98be6cb7c674631c08f257f0f361bdba" args="(process_info_block_t *allocatedListOfInfBlks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t top           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_s_y_s_t_e_m___a_p_i.html#g3be61222bdb3a1adfbf7720dec596851">process_info_block_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocatedListOfInfBlks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns current info for all processes in the OS, processInfoBlock_t is a special datatyp which is only used for the <a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g98be6cb7c674631c08f257f0f361bdba">top()</a> command, parameter allocatedListOfInfBlocks has to be a already allocated list, length of list is defined by function return value <a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g464f3d8698435a2cce5660213ad5e2a1">get_nr_of_processes()</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocatedListOfInfBlocks</em>&nbsp;</td><td>allocated list of process info blocks (linked list) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if fine, otherwise -1 (E.g. if length of allocated) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge4efef9d981ec735fdb928fa859e90c8"></a><!-- doxytag: member="sched.h::updateAllSupendedTasks" ref="ge4efef9d981ec735fdb928fa859e90c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateAllSupendedTasks           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates/reorganizes the SUSPENDED tasks queue, all suspended tasks will be checked if they can be put back to runnable queue <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group___s_c_h_e_d_u_l_e_r.html#g915e6a1a7af8610eb748b2a71aed8e25">putTask_to_SUSPENDEDQ()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbc336985438a0d2ef4e4386aca2fec83"></a><!-- doxytag: member="sched.h::updateCpuTimes" ref="gbc336985438a0d2ef4e4386aca2fec83" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateCpuTimes           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates all ticks for process they are in runnable, iowaiting or running state, also the IdleTask has counted time ticks which should indicate the usability of the system Each CPU_TIME_... shows the ticks of running or waiting. Multiply these ticks with the scheduling time-slice size ! 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Feb 8 18:43:25 2009 for Halos by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
